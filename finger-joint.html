<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Finger Joint</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0f0e0d; width: 100vw; height: 100vh; overflow: hidden; }
    canvas { display: block; }
    #title {
      position: absolute; top: 28px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.28); font-size: 10px; letter-spacing: 0.3em;
      text-transform: uppercase; white-space: nowrap;
      font-family: 'Helvetica Neue', sans-serif; font-weight: 300;
    }
    .part-label {
      position: absolute;
      font-family: 'Helvetica Neue', sans-serif; font-size: 9px; font-weight: 400;
      letter-spacing: 0.22em; text-transform: uppercase;
      pointer-events: none; transform: translate(-50%, -50%);
    }
    #lbl-a { color: rgba(140, 185, 255, 0.7); }
    #lbl-b { color: rgba(255, 100, 190, 0.7); }
    #btn {
      position: absolute; bottom: 44px; left: 50%; transform: translateX(-50%);
      background: transparent; border: 1px solid rgba(255,255,255,0.22);
      color: rgba(255,255,255,0.6); font-family: 'Helvetica Neue', sans-serif;
      font-size: 9px; font-weight: 400; letter-spacing: 0.28em; text-transform: uppercase;
      padding: 13px 36px; cursor: pointer; min-width: 160px;
      transition: border-color 0.25s, color 0.25s, background 0.25s;
    }
    #btn:not(:disabled):hover { border-color: rgba(255,255,255,0.55); color: rgba(255,255,255,0.9); background: rgba(255,255,255,0.05); }
    #btn:disabled { opacity: 0.3; cursor: default; }
    #hint { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.18); font-family: 'Helvetica Neue', sans-serif; font-size: 8px; letter-spacing: 0.2em; text-transform: uppercase; white-space: nowrap; }
  </style>
</head>
<body>
  <div id="title">Finger Joint</div>
  <div class="part-label" id="lbl-a">Piece A</div>
  <div class="part-label" id="lbl-b">Piece B</div>
  <button id="btn">Insert</button>
  <div id="hint">Drag to orbit &nbsp;·&nbsp; Scroll to zoom</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // ── SCENE ─────────────────────────────────────────────────
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f0e0d);
    scene.fog = new THREE.FogExp2(0x0f0e0d, 0.038);

    let W = window.innerWidth, H = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(38, W / H, 0.1, 80);
    // View the L-shaped corner from a nice angle
    camera.position.set(-2.0, 2.6, 4.4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(W, H);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(-0.5, 0, 0.8);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 2.5;
    controls.maxDistance = 18;
    camera.lookAt(controls.target);

    // ── LIGHTING ──────────────────────────────────────────────
    scene.add(new THREE.AmbientLight(0xddeeff, 0.42));

    const sun = new THREE.DirectionalLight(0xffffff, 1.4);
    sun.position.set(4, 9, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.left = -6; sun.shadow.camera.right  =  6;
    sun.shadow.camera.top  =  6; sun.shadow.camera.bottom = -6;
    sun.shadow.camera.near = 1;  sun.shadow.camera.far    = 30;
    sun.shadow.bias = -0.0008;
    scene.add(sun);

    const blueRim = new THREE.DirectionalLight(0x4488dd, 1.0);
    blueRim.position.set(5, 2, -3);
    scene.add(blueRim);

    const pinkRim = new THREE.DirectionalLight(0xff44aa, 0.35);
    pinkRim.position.set(-4, 2, 6);
    scene.add(pinkRim);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(28, 28),
      new THREE.MeshLambertMaterial({ color: 0x0a0908 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -1.3;
    floor.receiveShadow = true;
    scene.add(floor);

    // ── HELPERS ───────────────────────────────────────────────
    function mkMesh(geo, mat) {
      const m = new THREE.Mesh(geo, mat);
      m.castShadow = true; m.receiveShadow = true;
      return m;
    }
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.28 });
    function addBar(group, geo, pos, mat) {
      const m = mkMesh(geo, mat);
      m.position.copy(pos);
      group.add(m);
      const e = new THREE.LineSegments(new THREE.EdgesGeometry(geo), edgeMat);
      e.position.copy(pos);
      group.add(e);
    }

    // ── MATERIALS ─────────────────────────────────────────────
    const matA = new THREE.MeshPhongMaterial({
      color: 0x0b203f, shininess: 90,
      specular: new THREE.Color(0x5599ee),
      emissive: new THREE.Color(0x05101f)
    });
    const matB = new THREE.MeshPhongMaterial({
      color: 0xeb008b, shininess: 35,
      specular: new THREE.Color(0xff88cc)
    });

    // ── FINGER JOINT GEOMETRY ─────────────────────────────────
    //
    //  Coordinate frame:
    //    Piece A (navy) : flat board in XY, extends along −X, thickness T in Z
    //    Piece B (pink) : flat board in ZY, extends along +Z, thickness T in X
    //    Inner corner   : world origin (0, 0, 0)
    //
    //  Piece A occupies z from 0→T. Its body is x from −BW→0.
    //  At x=0→T its 3 fingers protrude into the corner block.
    //
    //  Piece B occupies x from 0→T. Its body is z from T→BL
    //  (body starts at z=T so A's fingers can sit in z 0→T).
    //  At z from 0→T its 2 tabs fill the gaps left by A's fingers.
    //
    //  Corner block (x:0→T, z:0→T):
    //    A fingers at y = −2fh, 0, +2fh  (fill it in z entirely)
    //    B tabs    at y = −fh,  +fh      (fill it in x entirely)
    //    No two pieces share any XZ column at the same Y → no overlap
    //
    //  Outer faces when joined:
    //    A's outer face: z = T
    //    B's outer face: x = T
    //    → clean flush L-corner ✓
    //
    //  B slides in from +X (right) to join A.
    // ─────────────────────────────────────────────────────────

    const T   = 0.36;         // board thickness
    const fh  = 0.34;         // finger segment height
    const BH  = 5 * fh;       // total board height ≈ 1.7
    const BW  = 1.65;         // A body length along −X
    const BL  = 1.65;         // B body length along +Z

    const AY = [-2*fh, 0,  2*fh];   // A finger y-centres
    const BY = [-fh,       fh  ];   // B tab y-centres

    // ── PIECE A (NAVY) ────────────────────────────────────────
    // All geometry at z from 0 to T (centred at z = T/2).

    const groupA = new THREE.Group();

    // Body: x from −BW to 0
    addBar(groupA,
      new THREE.BoxGeometry(BW, BH, T),
      new THREE.Vector3(-BW / 2, 0, T / 2),
      matA
    );

    // 3 fingers: x from 0 to T, z from 0 to T, at A's y-positions
    for (const fy of AY) {
      addBar(groupA,
        new THREE.BoxGeometry(T, fh, T),
        new THREE.Vector3(T / 2, fy, T / 2),
        matA
      );
    }

    scene.add(groupA);

    // ── PIECE B (PINK) ────────────────────────────────────────
    // All geometry at x from 0 to T (centred at x = T/2).
    // groupB.position.x is animated.

    const groupB = new THREE.Group();

    // Body: z from T to BL (clear of the finger zone)
    addBar(groupB,
      new THREE.BoxGeometry(T, BH, BL - T),
      new THREE.Vector3(T / 2, 0, T + (BL - T) / 2),
      matB
    );

    // 2 tabs: x from 0 to T, z from 0 to T, at B's y-positions
    // These slot into the gaps between A's fingers.
    for (const by of BY) {
      addBar(groupB,
        new THREE.BoxGeometry(T, fh, T),
        new THREE.Vector3(T / 2, by, T / 2),
        matB
      );
    }

    const B_JOINED_X    = 0;
    const B_SEPARATED_X = 2.8;
    groupB.position.x = B_SEPARATED_X;
    scene.add(groupB);

    // ── ANIMATION ─────────────────────────────────────────────
    let state = 'separated', progress = 0, dir = 0;
    const DURATION = 1.5;

    const btn = document.getElementById('btn');
    btn.addEventListener('click', () => {
      if (state === 'animating') return;
      dir = state === 'separated' ? 1 : -1;
      state = 'animating';
      btn.disabled = true;
    });

    function ease(t) {
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3) / 2;
    }

    // ── LABELS ────────────────────────────────────────────────
    const lblA = document.getElementById('lbl-a');
    const lblB = document.getElementById('lbl-b');
    const tmpV = new THREE.Vector3();

    function placeLabel(el, group, lx, ly, lz) {
      tmpV.set(lx, ly, lz).applyMatrix4(group.matrixWorld);
      tmpV.project(camera);
      el.style.left = ((tmpV.x + 1) / 2 * W) + 'px';
      el.style.top  = ((-tmpV.y + 1) / 2 * H) + 'px';
    }

    // ── RENDER LOOP ───────────────────────────────────────────
    let lastMs = 0;
    function tick(ms) {
      requestAnimationFrame(tick);
      const dt = Math.min((ms - lastMs) / 1000, 0.05);
      lastMs = ms;

      if (state === 'animating') {
        progress += dir * dt / DURATION;
        progress = Math.max(0, Math.min(1, progress));
        groupB.position.x = B_SEPARATED_X + ease(progress) * (B_JOINED_X - B_SEPARATED_X);
        if (progress <= 0 || progress >= 1) {
          state = progress >= 1 ? 'joined' : 'separated';
          btn.disabled = false;
          btn.textContent = state === 'joined' ? 'Separate' : 'Insert';
        }
      }

      controls.update();

      // A label: above A's body centre
      placeLabel(lblA, groupA, -BW / 2, BH / 2 + 0.28, T / 2);
      // B label: above B's body centre
      placeLabel(lblB, groupB, T / 2, BH / 2 + 0.28, T + (BL - T) / 2);

      renderer.render(scene, camera);
    }
    tick(0);

    window.addEventListener('resize', () => {
      W = window.innerWidth; H = window.innerHeight;
      camera.aspect = W / H;
      camera.updateProjectionMatrix();
      renderer.setSize(W, H);
    });
  </script>
</body>
</html>
