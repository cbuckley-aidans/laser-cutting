<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mortise &amp; Tenon Joint</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0f0e0d; width: 100vw; height: 100vh; overflow: hidden; }
    canvas { display: block; }
    #title {
      position: absolute; top: 28px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.28); font-size: 10px; letter-spacing: 0.3em;
      text-transform: uppercase; white-space: nowrap;
      font-family: 'Helvetica Neue', sans-serif; font-weight: 300;
    }
    .part-label {
      position: absolute;
      font-family: 'Helvetica Neue', sans-serif; font-size: 9px; font-weight: 400;
      letter-spacing: 0.22em; text-transform: uppercase;
      pointer-events: none; transform: translate(-50%, -50%);
    }
    #lbl-mortise { color: rgba(140, 185, 255, 0.7); }
    #lbl-tenon   { color: rgba(255, 100, 190, 0.7); }
    #btn {
      position: absolute; bottom: 44px; left: 50%; transform: translateX(-50%);
      background: transparent; border: 1px solid rgba(255,255,255,0.22);
      color: rgba(255,255,255,0.6); font-family: 'Helvetica Neue', sans-serif;
      font-size: 9px; font-weight: 400; letter-spacing: 0.28em; text-transform: uppercase;
      padding: 13px 36px; cursor: pointer; min-width: 160px;
      transition: border-color 0.25s, color 0.25s, background 0.25s;
    }
    #btn:not(:disabled):hover { border-color: rgba(255,255,255,0.55); color: rgba(255,255,255,0.9); background: rgba(255,255,255,0.05); }
    #btn:disabled { opacity: 0.3; cursor: default; }
    #hint { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.18); font-family: 'Helvetica Neue', sans-serif; font-size: 8px; letter-spacing: 0.2em; text-transform: uppercase; white-space: nowrap; }
  </style>
</head>
<body>
  <div id="title">Mortise &amp; Tenon Joint</div>
  <div class="part-label" id="lbl-mortise">Mortise</div>
  <div class="part-label" id="lbl-tenon">Tenon</div>
  <button id="btn">Insert</button>
  <div id="hint">Drag to orbit &nbsp;Â·&nbsp; Scroll to zoom</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f0e0d);
    scene.fog = new THREE.FogExp2(0x0f0e0d, 0.055);

    let W = window.innerWidth, H = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(38, W / H, 0.1, 80);
    camera.position.set(3.6, 2.2, 4.4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(W, H);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, -0.1, -0.4);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 2.5;
    controls.maxDistance = 16;
    camera.lookAt(controls.target);

    // Lighting
    scene.add(new THREE.AmbientLight(0xddeeff, 0.45));

    const sun = new THREE.DirectionalLight(0xffffff, 1.4);
    sun.position.set(6, 10, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.left   = -6; sun.shadow.camera.right  =  6;
    sun.shadow.camera.top    =  6; sun.shadow.camera.bottom = -6;
    sun.shadow.camera.near   = 1;  sun.shadow.camera.far    = 30;
    sun.shadow.bias = -0.0008;
    scene.add(sun);

    // Blue fill for navy piece visibility
    const blueRim = new THREE.DirectionalLight(0x4488dd, 0.9);
    blueRim.position.set(-5, 3, -4);
    scene.add(blueRim);

    const pinkRim = new THREE.DirectionalLight(0xff44aa, 0.3);
    pinkRim.position.set(4, 2, 6);
    scene.add(pinkRim);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(24, 24),
      new THREE.MeshLambertMaterial({ color: 0x0a0908 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.72;
    floor.receiveShadow = true;
    scene.add(floor);

    function mkMesh(geo, mat) {
      const m = new THREE.Mesh(geo, mat);
      m.castShadow = true; m.receiveShadow = true;
      return m;
    }

    // Materials
    const matMortise = new THREE.MeshPhongMaterial({
      color: 0x0b203f, shininess: 90,
      specular: new THREE.Color(0x5599ee),
      emissive: new THREE.Color(0x05101f)
    });
    const matTenon = new THREE.MeshPhongMaterial({
      color: 0xeb008b, shininess: 35,
      specular: new THREE.Color(0xff88cc)
    });

    // Geometry constants
    const PW = 1.0, PH = 1.0, PD = 1.8;
    const SW = 0.38, SH = 0.38, SD = 0.72;
    const tbH = (PH - SH) / 2;
    const ckW = (PW - SW) / 2;

    // Mortise piece
    const mortiseGroup = new THREE.Group();

    const tw = mkMesh(new THREE.BoxGeometry(PW, tbH, PD), matMortise);
    tw.position.y = SH / 2 + tbH / 2;
    mortiseGroup.add(tw);

    const bw = mkMesh(new THREE.BoxGeometry(PW, tbH, PD), matMortise);
    bw.position.y = -(SH / 2 + tbH / 2);
    mortiseGroup.add(bw);

    const lk = mkMesh(new THREE.BoxGeometry(ckW, SH, PD), matMortise);
    lk.position.x = -(SW / 2 + ckW / 2);
    mortiseGroup.add(lk);

    const rk = mkMesh(new THREE.BoxGeometry(ckW, SH, PD), matMortise);
    rk.position.x = SW / 2 + ckW / 2;
    mortiseGroup.add(rk);

    const fillLen = PD - SD;
    const cf = mkMesh(new THREE.BoxGeometry(SW, SH, fillLen), matMortise);
    cf.position.set(0, 0, -PD / 2 + fillLen / 2);
    mortiseGroup.add(cf);

    const outlineEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(PW, PH, PD)),
      new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.22 })
    );
    mortiseGroup.add(outlineEdges);

    mortiseGroup.position.set(0, 0, -0.5 - PD / 2);
    scene.add(mortiseGroup);

    // Tenon piece
    const tenonGroup = new THREE.Group();

    const body = mkMesh(new THREE.BoxGeometry(PW, PH, PD), matTenon);
    tenonGroup.add(body);

    const tn = mkMesh(new THREE.BoxGeometry(SW, SH, SD), matTenon);
    tn.position.set(0, 0, -(PD / 2 + SD / 2));
    tenonGroup.add(tn);

    const bodyEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(PW, PH, PD)),
      new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.22 })
    );
    tenonGroup.add(bodyEdges);

    const tenEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(SW, SH, SD)),
      new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.22 })
    );
    tenEdges.position.copy(tn.position);
    tenonGroup.add(tenEdges);

    const JOINED_Z    =  PD / 2 - 0.5;
    const SEPARATED_Z =  JOINED_Z + 2.1;
    tenonGroup.position.set(0, 0, SEPARATED_Z);
    scene.add(tenonGroup);

    // Animation
    let state = 'separated', progress = 0, dir = 0;
    const DURATION = 1.5;

    const btn = document.getElementById('btn');
    btn.addEventListener('click', () => {
      if (state === 'animating') return;
      dir = state === 'separated' ? 1 : -1;
      state = 'animating';
      btn.disabled = true;
    });

    function ease(t) {
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    }

    const lblMortise = document.getElementById('lbl-mortise');
    const lblTenon   = document.getElementById('lbl-tenon');
    const tmpV = new THREE.Vector3();

    function placeLabel(el, group, offsetY) {
      tmpV.set(0, offsetY, 0).applyMatrix4(group.matrixWorld);
      tmpV.project(camera);
      el.style.left = ((tmpV.x + 1) / 2 * W) + 'px';
      el.style.top  = ((-tmpV.y + 1) / 2 * H) + 'px';
    }

    let lastMs = 0;
    function tick(ms) {
      requestAnimationFrame(tick);
      const dt = Math.min((ms - lastMs) / 1000, 0.05);
      lastMs = ms;

      if (state === 'animating') {
        progress += dir * dt / DURATION;
        progress = Math.max(0, Math.min(1, progress));
        tenonGroup.position.z = SEPARATED_Z + ease(progress) * (JOINED_Z - SEPARATED_Z);
        if (progress <= 0 || progress >= 1) {
          state = progress >= 1 ? 'joined' : 'separated';
          btn.disabled = false;
          btn.textContent = state === 'joined' ? 'Separate' : 'Insert';
        }
      }

      controls.update();
      placeLabel(lblMortise, mortiseGroup, PH / 2 + 0.28);
      placeLabel(lblTenon,   tenonGroup,   PH / 2 + 0.28);
      renderer.render(scene, camera);
    }
    tick(0);

    window.addEventListener('resize', () => {
      W = window.innerWidth; H = window.innerHeight;
      camera.aspect = W / H;
      camera.updateProjectionMatrix();
      renderer.setSize(W, H);
    });
  </script>
</body>
</html>
